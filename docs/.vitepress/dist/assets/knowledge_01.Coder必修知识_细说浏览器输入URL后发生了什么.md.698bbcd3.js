import{_ as e,o as l,c as i,a as t}from"./app.03965981.js";const a="/xuanmu-blogs/assets/img-2023-02-26-20-30-38.15d17b1a.png",r="/xuanmu-blogs/assets/img-2023-02-26-20-31-49.1dc44b7c.png",s="/xuanmu-blogs/assets/img-2023-02-26-20-34-08.f7ab1f22.png",n="/xuanmu-blogs/assets/img-2023-02-26-20-34-26.4a6373f8.png",p="/xuanmu-blogs/assets/img-2023-02-26-20-39-46.fb7313cc.png",d="/xuanmu-blogs/assets/img-2023-02-26-20-40-38.8ee68e7b.png",o="/xuanmu-blogs/assets/img-2023-02-26-20-41-33.b6d18b43.png",h="/xuanmu-blogs/assets/img-2023-02-26-20-42-00.2c6209d0.png",c="/xuanmu-blogs/assets/img-2023-02-26-20-42-36.c27d4d21.png",_="/xuanmu-blogs/assets/img-2023-02-26-20-43-26.8ceb6ab0.png",x=JSON.parse('{"title":"细说浏览器输入URL后发生了什么","description":"","frontmatter":{},"headers":[{"level":2,"title":"总体概览","slug":"总体概览","link":"#总体概览","children":[]},{"level":2,"title":"1 合成URL(检查URL)","slug":"_1-合成url-检查url","link":"#_1-合成url-检查url","children":[]},{"level":2,"title":"2 DNS域名解析","slug":"_2-dns域名解析","link":"#_2-dns域名解析","children":[]},{"level":2,"title":"3 建立TCP连接","slug":"_3-建立tcp连接","link":"#_3-建立tcp连接","children":[]},{"level":2,"title":"4 发送HTTP请求，服务器处理请求，返回响应结果","slug":"_4-发送http请求-服务器处理请求-返回响应结果","link":"#_4-发送http请求-服务器处理请求-返回响应结果","children":[]},{"level":2,"title":"关闭TCP连接","slug":"关闭tcp连接","link":"#关闭tcp连接","children":[]},{"level":2,"title":"5 浏览器渲染","slug":"_5-浏览器渲染","link":"#_5-浏览器渲染","children":[]},{"level":2,"title":"6 构建 DOM 树","slug":"_6-构建-dom-树","link":"#_6-构建-dom-树","children":[]},{"level":2,"title":"7 样式计算","slug":"_7-样式计算","link":"#_7-样式计算","children":[]},{"level":2,"title":"8 页面布局","slug":"_8-页面布局","link":"#_8-页面布局","children":[]},{"level":2,"title":"9 生成分层树","slug":"_9-生成分层树","link":"#_9-生成分层树","children":[]},{"level":2,"title":"10 栅格化","slug":"_10-栅格化","link":"#_10-栅格化","children":[]},{"level":2,"title":"11 显示","slug":"_11-显示","link":"#_11-显示","children":[]}],"relativePath":"knowledge/01.Coder必修知识/细说浏览器输入URL后发生了什么.md"}'),u={name:"knowledge/01.Coder必修知识/细说浏览器输入URL后发生了什么.md"},S=t('<h1 id="细说浏览器输入url后发生了什么" tabindex="-1">细说浏览器输入URL后发生了什么 <a class="header-anchor" href="#细说浏览器输入url后发生了什么" aria-hidden="true">#</a></h1><p>作者：今天要比昨天更优秀 链接：<a href="https://juejin.cn/post/7073360584749613069" target="_blank" rel="noreferrer">https://juejin.cn/post/7073360584749613069</a></p><h2 id="总体概览" tabindex="-1">总体概览 <a class="header-anchor" href="#总体概览" aria-hidden="true">#</a></h2><p>大体上，可以分为六步，当然每一步都可以详细都展开来说，这里先放一张总览图: <img src="'+a+'" alt=""></p><h2 id="_1-合成url-检查url" tabindex="-1">1 合成URL(检查URL) <a class="header-anchor" href="#_1-合成url-检查url" aria-hidden="true">#</a></h2><p>看用户的输入是url还是搜索内容（看是否符合url规则），url进行DNS域名解析，要是搜索内容结合搜索引擎转化为url，然后进行DNS域名解析</p><h2 id="_2-dns域名解析" tabindex="-1">2 DNS域名解析 <a class="header-anchor" href="#_2-dns域名解析" aria-hidden="true">#</a></h2><p>在网络世界，你肯定记得住网站的名称，但是很难记住网站的 IP 地址，因而也需要一个地址簿，就是 DNS 服务器。DNS 服务器是高可用、高并发和分布式的，它是树状结构，如图： <img src="'+r+'" alt=""></p><ul><li>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器 ：返回相应主机的 IP 地址</li></ul><p>DNS的域名查找，在客户端和浏览器，本地DNS之间的查询方式是递归查询；在本地DNS服务器与根域及其子域之间的查询方式是迭代查询；</p><p>递归过程：</p><p>在客户端输入 URL 后，会有一个递归查找的过程，从浏览器缓存中查找-&gt;本地的hosts文件查找-&gt;找本地DNS解析器缓存查找-&gt;本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。</p><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询</p><p>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</p><p>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</p><ul><li><p>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p></li><li><p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</p></li><li><p>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</p><p>迭代查找过程如下图：</p></li></ul><p><img src="'+s+'" alt=""></p><p>递归迭代结合起来的过程，可以用一个图表示：</p><p><img src="'+n+'" alt=""></p><p>在查找过程中，有以下优化点：</p><ul><li>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</li><li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li></ul><h2 id="_3-建立tcp连接" tabindex="-1">3 建立TCP连接 <a class="header-anchor" href="#_3-建立tcp连接" aria-hidden="true">#</a></h2><p>首先，判断是不是https的，如果是，则HTTPS其实是HTTP + SSL / TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。</p><p>进行三次握手，建立TCP连接。</p><ol><li><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p></li><li><p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p></li><li><p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><p>注：TCP三次握手完成后，若是https这时会进行SSL握手</p></li></ol><p><strong>备注</strong></p><ul><li><p>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</p></li><li><p>SYN(SYNchronization)：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</p></li><li><p>FIN(finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p></li></ul><h2 id="_4-发送http请求-服务器处理请求-返回响应结果" tabindex="-1">4 发送HTTP请求，服务器处理请求，返回响应结果 <a class="header-anchor" href="#_4-发送http请求-服务器处理请求-返回响应结果" aria-hidden="true">#</a></h2><p>TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.</p><h2 id="关闭tcp连接" tabindex="-1">关闭TCP连接 <a class="header-anchor" href="#关闭tcp连接" aria-hidden="true">#</a></h2><ol><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我&quot;同意&quot;你的关闭请求；</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ol><h2 id="_5-浏览器渲染" tabindex="-1">5 浏览器渲染 <a class="header-anchor" href="#_5-浏览器渲染" aria-hidden="true">#</a></h2><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。如图： <img src="'+p+'" alt=""></p><ol><li>渲染进程将 HTML 内容转换为能够读懂DOM 树结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。</li><li>合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。</li></ol><h2 id="_6-构建-dom-树" tabindex="-1">6 构建 DOM 树 <a class="header-anchor" href="#_6-构建-dom-树" aria-hidden="true">#</a></h2><p>浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树,先将HTML的原始字节数据转换为文件指定编码的字符,然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。</p><p><img src="'+d+'" alt=""></p><p>具体步骤：</p><ol><li>转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</li><li>Tokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</li><li>构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）</li><li>构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系</li></ol><h2 id="_7-样式计算" tabindex="-1">7 样式计算 <a class="header-anchor" href="#_7-样式计算" aria-hidden="true">#</a></h2><p>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</p><p>CSS 样式来源主要有 3 种，分别是通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。,其样式计算过程主要为：</p><p><img src="'+o+'" alt=""></p><p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。处理完成后再处理样式的继承和层叠，有些文章将这个过程称为CSSOM的构建过程。</p><h2 id="_8-页面布局" tabindex="-1">8 页面布局 <a class="header-anchor" href="#_8-页面布局" aria-hidden="true">#</a></h2><p>布局过程，即排除 script、meta 等功能化、非视觉节点，排除 display: none 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图：</p><p><img src="'+h+'" alt=""></p><h2 id="_9-生成分层树" tabindex="-1">9 生成分层树 <a class="header-anchor" href="#_9-生成分层树" aria-hidden="true">#</a></h2><p>页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），如图：</p><p><img src="'+c+'" alt=""></p><p>在浏览器中，你可以打开 Chrome 的&quot;开发者工具&quot;，选择&quot;Layers&quot;标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。</p><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p><h2 id="_10-栅格化" tabindex="-1">10 栅格化 <a class="header-anchor" href="#_10-栅格化" aria-hidden="true">#</a></h2><p>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。如图： <img src="'+_+'" alt=""></p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><h2 id="_11-显示" tabindex="-1">11 显示 <a class="header-anchor" href="#_11-显示" aria-hidden="true">#</a></h2><p>最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。</p>',57),m=[S];function g(N,T,b,C,P,f){return l(),i("div",null,m)}const k=e(u,[["render",g]]);export{x as __pageData,k as default};
